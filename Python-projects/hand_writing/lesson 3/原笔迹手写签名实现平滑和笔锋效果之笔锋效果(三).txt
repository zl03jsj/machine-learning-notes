通过前面两篇文章, 我们已经解决了在手写笔迹中的平滑问题. 本篇将讲解如何让手写笔迹能够有笔锋效果.

想要让笔迹能够有笔锋的效果, 那么整个笔迹肯定不可能是等宽的.也就是说, 要让我们绘制出来的笔迹线条必须要有一定的粗细变化.

所有人都能够很自然的想到 粗细变化的原理: 运动快的地方肯定线条应该更细, 运动慢的的地方细条应该更粗.是的, 这是最基本的原理, 这个想法完全正确.

说点题外话, 最近在看机器学习, 神经网络模型里面有一个叫:激活函数的东西, 它的作用就是为了让神经网络具有分层的非线性映射学习的能力,
如果完全是线性的, 在处理某些复杂情况时,得到的结果会很糟糕.

同样, 我们在处理手写笔迹的时候, 线条的粗细也不应该完全和速度是一种线性的变化关系,.

事实上, 如果完全按照一种线性的变化关系, 绘制出来的线条会看起来非常奇怪(亲测完全如此).

所以, 在计算线条粗细的时候, 在遵循"速度越快的地方,线条更细; 速度慢的地方,线条更粗" 这一条基本准则的前提下,
也应该根据一些具体情况, 让线条的粗细变化具有"非线性"的能力.

 

下面我基于手写的实际情况,提出一些问题, 大家可以稍微思考一下:

1) 假设我们的计算线条笔宽的函数就是: W_current = k * s, 其中s为当前线段笔迹点移动的速度, k为将速度映射为笔宽的一个固定系数.
用户移动时, 得到了3个相邻的点依次分别为:a,b,c, 在ab线段, 移动速度接近无限大, 而在bc段移动的速度无限接近0, 
事实上, 在手写笔迹的时候,完全有可能 前一段移动速度非常快, 到下一段距离的时候, 移动速度就立刻变得非常慢了.
我只是把可能遇到的情况进行了夸张, 那么, 在这种情况下,我们应该如何处理线条的粗细呢?

2) 同样假设3个点, 两条线段ab, bc, cd, 并且假设ab, bc有足够的长度, 使得我们计算出来的宽度变化看起来也是比较合理的, 这样说可能不太容易理解.
举个栗子: ab, bc的线段长度都为100个像素, 计算出ab线段线条的宽度应该是5, bc线段的线条宽度该是10,
从真实手写的情况来看, 200个像素长度的笔迹, 只有5个像素的宽度变化,这是完全合理的. 
那么,如果我们用宽度5来绘制线段ab, 然后用宽度10来绘制线段bc, 我们绘制出来的笔迹是什么样子的? (发挥一下想象力)

3) 在真实手写的情况下, 文字的笔迹的笔锋主要体现在文字的哪些部位?

下面我们分别讨论这3个问题.
问题一: 
如果完全按照线性函数W_current = k * s 来计算宽度, 相邻两端线条的笔宽变化有可能非常大, 大到超出了我们可以的接受范围. 
所以我们考虑通过某种方式来限制这种突然的变化, 让线条宽度的变化看起来更自然.
下面是我修正以后的计算线条宽度的函数:
W_current = 
　　W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) >= 0
　　W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) < 0
　　W_current 　　　　  当前线段的宽度
　　W_previous　　　　与当前线条相邻的前一条线段的宽度
　　distance 　　	　　    当前线条的长度
　　w_k 　　　　　　　	设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量. 
　　distance * w_k 　　  即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少.
这个函数多引入了2个变量(前一条线段的宽度, 还有当前的线段的距离), 在计算线条宽度时, 考虑了更多的可能性. 
还增加了一种非线性的变化机制, min.这个min就是我们的"激活函数".让我们的线宽不再只具有线性的变化了.
现在, 这个计算线宽的函数,看起来已经比较完美了.

问题二:
我们直接看一个我故意做得比较不好的示范图:



虽然这个效果大致看起来看还行, 作为一名追求完美的程序员, 始终觉得什么地方不对劲.

那么我们再把这个问题放大到一种极端的情况:

 



这样问题就很明显了.

我解决这个问题的方式是:利用微分的思想, 把线段再次细分成多条子线段, 宽度的变化均匀的分布在这些细分的子线段上.

这样, 我们的线条宽度变化看起来就更加自然了.

 

问题三:

在平时的书写过程中, 笔锋主要体现在笔画的起始位置, 转角位置, 和笔画结束的位置.

在笔迹转角的位置体现出笔锋看起来比较困难, 但是在笔迹开始和结束的地方做一些文章还是比较容易.

我的具体做法是这样, 在笔迹开始的前5个点(这个'5', 是我随便想出来的, 也可4,6,7,8), 让笔迹的宽细变化更加明显

在笔迹的结束位置, 不管之前的线段宽度是多少, 都让其在最后位置收缩为最小笔宽. 

更好的理由我也说不出来为什么,应该是属于程序员的第七感吧, 感觉这样做会比较好. 而且事实证明效果的确不错.

其实这里也体现了"非线性"变化的思想, 因为我觉得这一点比较重要, 所以单独提出来.

 

解决以上3个问题, 离这个算法的成功, 就还差一些细节的问题了.(虽然是细节问题, 但是以下这几个需要注意的细节非常非常非常重要, 说三遍!!!!!!!)

下面我就不买关子, 直接告诉大家需要注意的地方:

1)  在实际的情况中, 移动 定位设备(鼠标,手写笔,或者触摸屏)时, 设备发送给我们的mouse_move消息会非常的多, 需要设立一个

　　时间阈值, 比如前一次消息到这一次消息的间隔时间小于30毫秒, 就把这个点废弃掉. 否则, 点太多, 每个都处理, 基本上都是多余的计算..

2) 在实际情况中, 需要设立一个距离阈值, 当本次得到的点, 到上一个点的距离小于这个阈值时, 把这个点舍弃掉, 距离太近, 也是多余的计算.

以上内容,  差不多就是手写笔迹算法中所有技术难点和需要注意的细节了.

 

下面把C++实现的源代码分享给大家, 其中手写笔迹的具体算法实现部分为z_math.h, z_math.c使用纯c实现,除了c标准库,没有其它任何依赖,可以毫无压力的移植到各个支持c/c++语言的任何平台.

后面的z_gdi+_render.h, z_gdi+_render.cpp,main.cpp为windows平台上示例代码的实现. 代码的具体细节我就不在这里啰嗦了.

z_math.h
z_math.c
z_gdi+_render.h
z_gdi+_render.cpp
main.cpp
 演示程序下载  github项目源代码(vs2017)

快乐的时光总是过得那么快, 留下的总是无尽的唏嘘和感叹, 又到时间和朋友们讲拜拜了!!!

最后展示一张在解决这些问题时,留下的真迹:



手写笔迹这一个系列总算是写完了.在这几篇原创文章中, 我有很多地方没有办法完全把自己的想法表达清楚,这可能也是很多程序员攻城狮的通病, 表达能力不怎么样.

如果大家有什么不清楚或者我说得有问题的地方, 可以在留言区留言.我会尽量回答.

下面!!!!!!!!我不得不再次提起一件很让我气愤的事情!!!!!!!

无良公司老板拖欠两个月工资了,  穷得叮当响,我靠!!!!!!!!现在每天吃8块钱的蛋炒饭, 早上点一份,中午吃一半, 晚上吃一半, 日子真实苦啊..

大家如果大家觉得这篇文章对您有帮助, 又愿意打赏一些银两, 请拿起你的手机, 打开你的微信, 扫一扫下方二维码, 作为一个有骨气的程序员攻城狮, 我非常愿意接受大家的支助...哈哈哈!!!



 